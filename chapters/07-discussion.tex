\chapter{Discussion}

\begin{center}
    \textit{The results are critically analyzed and discussed in this chapter. It explores the implications of the findings, identifies limitations, and suggests potential areas for future improvement.}
\end{center}

\section{Further development}
Throughout the duration of this project, several ideas for development emerged. These from both the team, the product owner, and external contributors. Due to the time constraints of the Bachelor’s thesis, many of these ideas were not implemented and were therefore categorized as "Further development". After the product owner's request, ensuring accurate piece recognition was prioritized over extended functionality.

\subsection{Independent application}
During the meeting with the product owner at Aalesund Schaklag's location, the product owner and the leader of the chess club discussed potential future developments. One idea was to implement a finished version of the application where cameras are permanently mounted on the ceiling at the club. Since the chess club typically maintains standard table arrangement for chessboards, the cameras would not need to be moved. \\

In this setup, the cameras would be connected to a computer located in a locked room, running the application continuously. The proposed solution involves connecting the system to a physical switch, enabling users to easily power the cameras and application on or off as needed. \\

A typical case would involve a group of chess players organizing a unofficial tournament. Upon arrival, the tables would already be positioned correctly under the cameras. The participants would set up their chessboards, pieces, and clocks, and then activate the system by turning on the switch. Once activated, the application would automatically start, and the cameras would begin reading the boards. Games would be tracked and displayed through the application in real time. Boards set back to their initial position would be recognized as reset. \\

After the tournament concludes, users could simply turn off the switch to shut down the system. This design enables the application to be used independently, without requiring technical expertise. It is intended to be accessible to both young adults and elderly users. Additionally, mounting the cameras on the ceiling contributes to enhanced security for the chess equipment.

\subsection{Analyze chess games}
An additional development idea involves giving both players and spectators ability to analyze completed chess games. Currently, the application generates a \gls{PGN} file once a game is completed. This file can be imported into external platforms such as \gls{lichess}, where users can step through each move and receive insights such as the opening name, evaluation of moves, and suggested best plays. \\

A proposed enhancement is to integrate the application directly with the \gls{stockfish} chess engine. By doing so, real-time analysis could be made available during ongoing games. This would allow spectators to view the current game evaluation — for example, indicating which player has the advantage at a given position. A common and effective way to display this is through an evaluation bar, which shifts visually based on the balance of the position, providing intuitive feedback to viewers. \\

This feature could be integrated into both the tournament- and board-view, displaying evaluations for each board during live play. Such functionality would enrich the viewing experience for spectators and could also be useful for players who wish to review their games afterward. After the match, players could access a breakdown of the game with move-by-move assessments and suggestions for improvement. \\

Integrating \gls{stockfish} would also open possibilities for additional automated insights, such as identifying blunders, mistakes, and inaccuracies, or offering engine-generated commentary. This would enhance the educational value of the application and make it more engaging for a broader range of users, including students, coaches, and casual players.

\subsection{Information about participants}
In the current version of the application, all tournament participants are hardcoded directly into the code. This approach was chosen to allow the development team to focus on core functionality, particularly the accurate detection of board states. \\

A more flexible and maintainable solution would involve allowing the tournament organizer to manually register participants once tournament registration is complete. This could be implemented through a user interface, such as a form, with participant data stored in a database. Relevant information for each player would typically include their name, age, chess club affiliation, and chess rating. \\

One potential enhancement is to fetch player ratings directly from \gls{fide}, the international chess federation. \gls{fide} maintains the \gls{elo} rating system, which is the most widely used system for evaluating chess players and is also used by Aalesund Schaklag. When a player’s match is recorded in the \gls{fide} system, their rating is updated accordingly. By integrating with the \gls{fide} API or database, the application could automatically retrieve up-to-date player ratings, ensuring accurate and consistent information for tournament use.

\subsection{Time control}
For spectators watching live chess games on a screen, it can be difficult to follow the pace of the game, as the current version of the application does not display any information about time control. Chess games are typically played with varying time formats, including standard (classical), \gls{blitz}, and \gls{bullet}, each of which allocates different amounts of time per player. Tournaments generally specify a single time control variant, which could be included in the tournament description. \\

A simple approach to improve spectator understanding would be to introduce a time control entity in the application. For example, if the tournament is set to use the \gls{blitz} format, the application could display an estimated countdown timer based on player moves. According to \gls{fide}, blitz games allocate 10 minutes or less per player. By knowing the variant in use, the application could estimate the time remaining based on the move timestamps. However, this method is not reliable, as several factors can introduce inaccuracies — such as delays in move detection, move registration, and rendering on the screen. As a result, this solution would not provide precise or trustworthy time tracking. \\

An alternative is to use a digital chess clock, similar to those used with electronic chess boards. These clocks can be connected to a computer via cable and provide accurate time tracking. However, this method increases the cost of the setup significantly. A single digital clock can cost around 1,500 NOK, which goes against the application’s goal of being a low-cost and low-maintenance solution. \\

A more advanced approach would involve reading the clock visually using the same camera system that tracks the chessboard. In this solution, a machine learning model would be trained to recognize and interpret both the chessboard and the physical clock from the same image. The backend could then update the front-end with real-time clock values. While this approach would preserve the low-cost vision by removing the need for expensive clock hardware, it comes with technical challenges. The machine learning model could misread the clock due to obstructions, poor lighting, or low image resolution. For example, if a player’s hand is covering part of the clock, the system might not be able to detect the time correctly. These inaccuracies are particularly problematic in faster time formats like blitz or bullet, where even small errors or delays can significantly affect the perceived game state. \\

Due to these limitations and the project's scope, implementing time control features was not prioritized in the current version of the application. However, the topic remains relevant for future development, especially for improving the spectator experience.

\section{Obstacles}
In addition to ideas for future development, there were also a few obstacles encountered during the development phase of this project. These challenges were addressed as they occurred, and solutions were implemented as part of the final application.

\subsection{Camera}
During the development and testing phase of the front-end application, an obstacle related to camera initialization was encountered. The application is designed to access an external USB camera by specifying a camera ID other than 0, since ID 0 typically corresponds to the system's default or built-in (dashboard) camera, which is not relevant to this project.\\

Two identical external webcams were used for this project, both connected via a USB hub. One of the cameras functioned correctly. When connected, the front-end application successfully initialized the camera feed, and the video stream was displayed on the webpage as expected.\\

However, the second camera, did not behave as expected. Despite being physically identical to the first camera and verified to work through the system's built-in camera application, the front-end application failed to display its video feed. Instead, it defaulted to camera ID 0, resulting in the system's dashboard camera being selected.\\

This issue was traced back to a cached or “ghost” device entry in the Windows Device Manager. A ghost device refers to a previously connected hardware device that is no longer physically attached to the system but whose configuration and driver information remain cached by the operating system. These leftover entries can lead to conflicts or incorrect device indexing when similar hardware is reconnected, especially when multiple identical devices are used. In this case, the system appeared to retain prior camera associations, which caused the application to misidentify or incorrectly assign the camera index.

\subsection{Special moves}
When a move is made, the front-end highlights the previous and current tiles of the moved piece. User testing with different color palettes resulted in the selection of a bright contrast color relative to the main design scheme to ensure good visibility. \\

The chessboard component manages the rules of chess, while the front-end is responsible only for storing tile positions and applying styling. In standard moves, highlighting the starting and ending tiles is sufficient. However, special moves such as \gls{castling}, pawn \gls{promotion}, and \gls{en-passant} capture require additional handling. \\

In \gls{castling}, both the king and a rook move simultaneously. Since the default highlight logic tracks only one piece, it does not correctly represent \gls{castling} moves. Additional logic was implemented to highlight the movements of both the king and rook during \gls{castling}, ensuring consistency and clarity for the user.